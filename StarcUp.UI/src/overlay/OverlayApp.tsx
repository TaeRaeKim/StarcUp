import React, { useState, useEffect, useCallback, useRef } from 'react'
import { CenterPositionData } from '../../electron/src/services/types'
import { WorkerStatus, type WorkerStatusRef } from './components/WorkerStatus'
import { OverlaySettingsPanel, type OverlaySettings } from './components/OverlaySettings'
import { type EffectType } from './hooks/useEffectSystem'

export function OverlayApp() {
  const [centerPosition, setCenterPosition] = useState<CenterPositionData | null>(null)
  const [isVisible, setIsVisible] = useState(true)
  const [connectionStatus, setConnectionStatus] = useState<'connecting' | 'connected' | 'disconnected'>('connecting')
  const [lastUpdateTime, setLastUpdateTime] = useState<Date | null>(null)
  const [updateCount, setUpdateCount] = useState(0)
  const [frameRate, setFrameRate] = useState(0)
  const [lastEventType, setLastEventType] = useState<'immediate' | 'debounced' | null>(null)
  
  // WorkerManager Ïù¥Î≤§Ìä∏ ÏÉÅÌÉú
  const [workerStatus, setWorkerStatus] = useState<any>(null)
  const [lastWorkerEvent, setLastWorkerEvent] = useState<string | null>(null)
  const [gameStatus, setGameStatus] = useState<string>('waiting') // 'waiting', 'playing', 'game-ended'
  const [isEditMode, setIsEditMode] = useState(false)
  const [workerPosition, setWorkerPosition] = useState({ x: 50, y: 50 })
  const [isSettingsOpen, setIsSettingsOpen] = useState(false)
  const workerStatusRef = useRef<WorkerStatusRef>(null)
  
  // Ïò§Î≤ÑÎ†àÏù¥ ÏÑ§Ï†ï ÏÉÅÌÉú
  const [overlaySettings, setOverlaySettings] = useState<OverlaySettings>({
    showWorkerStatus: true,
    showBuildOrder: false,
    showUnitCount: false,
    showUpgradeProgress: false,
    showPopulationWarning: false,
    opacity: 90
  })

  // Í∏∞Î≥∏ ÏúÑÏπòÎ°ú Î¶¨ÏÖãÌïòÎäî Ìï®Ïàò (Ïò§Î≤ÑÎ†àÏù¥ Ïª®ÌÖåÏù¥ÎÑà Í∏∞Ï§Ä)
  const resetToCenter = () => {
    const overlayContainer = document.querySelector('.overlay-container') as HTMLElement
    
    if (!overlayContainer) {
      console.warn('‚ö†Ô∏è Ïò§Î≤ÑÎ†àÏù¥ Ïª®ÌÖåÏù¥ÎÑàÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§')
      return
    }
    
    const containerRect = overlayContainer.getBoundingClientRect()
    
    // WorkerStatus ÏúÑÏπò Î¶¨ÏÖã
    const workerStatusElement = document.querySelector('.worker-status') as HTMLElement
    if (workerStatusElement) {
      const workerRect = workerStatusElement.getBoundingClientRect()
      const centerX = (containerRect.width - workerRect.width) / 2
      const centerY = (containerRect.height - workerRect.height) / 2
      
      setWorkerPosition({ x: centerX, y: centerY })
      console.log('üéØ WorkerStatus ÏúÑÏπò Ï§ëÏïôÏúºÎ°ú Î¶¨ÏÖã:', { x: centerX, y: centerY })
    }
  }

  useEffect(() => {
    // Electron APIÍ∞Ä ÏÇ¨Ïö© Í∞ÄÎä•ÌïúÏßÄ ÌôïÏù∏
    if (typeof window !== 'undefined' && window.electronAPI) {
      // Electron Î©îÏù∏ ÌîÑÎ°úÏÑ∏Ïä§Î°úÎ∂ÄÌÑ∞ Ï§ëÏïô ÏúÑÏπò Ï†ïÎ≥¥ ÏàòÏã†
      const electronAPI = window.electronAPI as any
      if (electronAPI.onUpdateCenterPosition) {
        setConnectionStatus('connected')
        const unsubscribe = electronAPI.onUpdateCenterPosition((data: CenterPositionData) => {
          console.log('üéØ Ïò§Î≤ÑÎ†àÏù¥ Ï§ëÏïô ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏:', data)
          setCenterPosition(data)
          setLastUpdateTime(new Date())
          setUpdateCount(prev => prev + 1)
          
          // Ïù¥Î≤§Ìä∏ ÌÉÄÏûÖ Í∞êÏßÄ (ÏΩòÏÜî Î°úÍ∑∏ Í∏∞Î∞ò Ï∂îÏ†ï)
          if (data.x && data.y) {
            setLastEventType('immediate') // Ïã§Ï†úÎ°úÎäî Îçî Ï†ïÌôïÌïú Î∞©Î≤ïÏù¥ ÌïÑÏöîÌïòÏßÄÎßå ÏùºÎã® immediateÎ°ú ÏÑ§Ï†ï
          }
        })
        
        return unsubscribe
      } else {
        setConnectionStatus('disconnected')
        console.warn('‚ö†Ô∏è onUpdateCenterPosition Î©îÏÑúÎìúÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§')
      }
    } else {
      setConnectionStatus('disconnected')
      console.warn('‚ö†Ô∏è Electron APIÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§')
    }
  }, [])

  // WorkerManager Ïù¥Î≤§Ìä∏ Íµ¨ÎèÖ
  useEffect(() => {
    if (typeof window !== 'undefined' && window.electronAPI) {
      const electronAPI = window.electronAPI as any

      // WorkerManager Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑàÎì§
      const removeWorkerStatusListener = electronAPI.onWorkerStatusChanged && electronAPI.onWorkerStatusChanged((data: any) => {
        console.log('üë∑ [Overlay] ÏùºÍæº ÏÉÅÌÉú Î≥ÄÍ≤Ω:', data)
        setWorkerStatus(data)
        setLastWorkerEvent('status-changed')
        
        // eventTypeÏóê Îî∞Î•∏ Ìö®Í≥º Ìä∏Î¶¨Í±∞
        if (data.eventType && workerStatusRef.current) {
          const effectType = data.eventType as EffectType
          if (effectType === 'ProductionCompleted' || effectType === 'WorkerDied') {
            console.log(`‚ú® [Overlay] ${effectType} Ìö®Í≥º Ìä∏Î¶¨Í±∞`)
            workerStatusRef.current.triggerEffect(effectType)
          }
        }
      })

      const removeGasAlertListener = electronAPI.onGasBuildingAlert && electronAPI.onGasBuildingAlert(() => {
        console.log('‚õΩ [Overlay] Í∞ÄÏä§ Í±¥Î¨º Ï±ÑÏ∑® Ï§ëÎã® ÏïåÎ¶º')
        setLastWorkerEvent('gas-alert')
      })

      const removePresetChangedListener = electronAPI.onWorkerPresetChanged && electronAPI.onWorkerPresetChanged((data: any) => {
        console.log('‚öôÔ∏è [Overlay] ÏùºÍæº ÌîÑÎ¶¨ÏÖã Î≥ÄÍ≤Ω:', data)
        setLastWorkerEvent('preset-changed')
      })

      return () => {
        if (removeWorkerStatusListener) removeWorkerStatusListener()
        if (removeGasAlertListener) removeGasAlertListener()
        if (removePresetChangedListener) removePresetChangedListener()
      }
    }
  }, [])

  // ÌîÑÎ†àÏûÑ Î†àÏù¥Ìä∏ Í≥ÑÏÇ∞
  useEffect(() => {
    const interval = setInterval(() => {
      const now = Date.now()
      if (lastUpdateTime) {
        const timeDiff = now - lastUpdateTime.getTime()
        if (timeDiff < 5000) { // 5Ï¥à Ïù¥ÎÇ¥ ÏóÖÎç∞Ïù¥Ìä∏Í∞Ä ÏûàÏóàÎã§Î©¥
          setFrameRate(Math.round(1000 / 16)) // 16ms throttling Í∏∞Ï§Ä ÏòàÏÉÅ FPS
        } else {
          setFrameRate(0)
        }
      }
    }, 1000) // 1Ï¥àÎßàÎã§ Í≥ÑÏÇ∞

    return () => clearInterval(interval)
  }, [lastUpdateTime])

  // Electron IPCÎ•º ÌÜµÌïú Ìé∏Ïßë Î™®Îìú ÌÜ†Í∏Ä
  useEffect(() => {
    if (typeof window !== 'undefined' && window.electronAPI) {
      const electronAPI = window.electronAPI as any
      
      // Ìé∏Ïßë Î™®Îìú ÌÜ†Í∏Ä Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
      if (electronAPI.onToggleEditMode) {
        console.log('üéØ Ìé∏Ïßë Î™®Îìú IPC Î¶¨Ïä§ÎÑà Îì±Î°ù')
        const unsubscribeEditMode = electronAPI.onToggleEditMode((data: { isEditMode: boolean }) => {
          console.log('üéØ Ìé∏Ïßë Î™®Îìú ÌÜ†Í∏Ä IPC Ïù¥Î≤§Ìä∏ ÏàòÏã†:', data.isEditMode)
          setIsEditMode(data.isEditMode)
        })
        
        // Í≤åÏûÑ ÏÉÅÌÉú Î≥ÄÍ≤Ω Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï∂îÍ∞Ä (coreAPIÏóêÏÑú Í∞ÄÏ†∏Ïò§Í∏∞)
        const coreAPI = (window as any).coreAPI
        const unsubscribeGameStatus = coreAPI && coreAPI.onGameStatusChanged && coreAPI.onGameStatusChanged((data: { status: string }) => {
          console.log('üéÆ [Overlay] Í≤åÏûÑ ÏÉÅÌÉú Î≥ÄÍ≤Ω:', data.status, '| ÌòÑÏû¨ workerStatus:', workerStatus ? 'EXISTS' : 'NULL')
          setGameStatus(data.status)
        })
        
        return () => {
          unsubscribeEditMode()
          if (unsubscribeGameStatus) unsubscribeGameStatus()
        }
      } else {
        console.warn('‚ö†Ô∏è onToggleEditMode Î©îÏÑúÎìúÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§')
      }
    } else {
      console.warn('‚ö†Ô∏è Electron APIÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§')
    }
  }, [])


  // Ìé∏ÏßëÎ™®ÎìúÍ∞Ä Ìï¥Ï†úÎê† Îïå ÏÑ§Ï†ïÏ∞Ω ÏûêÎèô Îã´Í∏∞
  useEffect(() => {
    if (!isEditMode && isSettingsOpen) {
      setIsSettingsOpen(false)
    }
  }, [isEditMode, isSettingsOpen])

  // ÏúàÎèÑÏö∞ ÏúÑÏπò/ÌÅ¨Í∏∞ Î≥ÄÍ≤Ω Í∞êÏßÄ Î∞è ÏïÑÏù¥ÌÖú ÏúÑÏπò Ï°∞Ï†ï (window-position-changed Ïù¥Î≤§Ìä∏ Í∏∞Î∞ò)
  useEffect(() => {
    if (!centerPosition) return

    const adjustItemPositions = () => {
      // Ïò§Î≤ÑÎ†àÏù¥ ÏúàÎèÑÏö∞Ïùò Ïã§Ï†ú ÌÅ¨Í∏∞ (Í≤åÏûÑ ÏòÅÏó≠ ÌÅ¨Í∏∞)
      const overlayWidth = centerPosition.gameAreaBounds.width
      const overlayHeight = centerPosition.gameAreaBounds.height
      
      console.log('üîß [ÏúÑÏπò Ï°∞Ï†ï] Ïò§Î≤ÑÎ†àÏù¥ ÌÅ¨Í∏∞:', { width: overlayWidth, height: overlayHeight })
      
      // WorkerStatus ÏúÑÏπò Ï°∞Ï†ï
      const workerStatusElement = document.querySelector('.worker-status') as HTMLElement
      if (workerStatusElement) {
        const workerRect = workerStatusElement.getBoundingClientRect()
        const newWorkerX = Math.max(0, Math.min(overlayWidth - workerRect.width, workerPosition.x))
        const newWorkerY = Math.max(0, Math.min(overlayHeight - workerRect.height, workerPosition.y))
        
        if (newWorkerX !== workerPosition.x || newWorkerY !== workerPosition.y) {
          console.log('üîß [ÏúÑÏπò Ï°∞Ï†ï] WorkerStatus:', { from: workerPosition, to: { x: newWorkerX, y: newWorkerY } })
          setWorkerPosition({ x: newWorkerX, y: newWorkerY })
        }
      }
    }

    // centerPositionÏù¥ Î≥ÄÍ≤ΩÎê† ÎïåÎßàÎã§ ÏúÑÏπò Ï°∞Ï†ï Ïã§Ìñâ
    setTimeout(adjustItemPositions, 100) // DOM ÏóÖÎç∞Ïù¥Ìä∏ ÌõÑ Ïã§ÌñâÌïòÍ∏∞ ÏúÑÌï¥ ÏßÄÏó∞
    
  }, [centerPosition, workerPosition])

  // ÏúàÎèÑÏö∞ ÌÅ¨Í∏∞Ïóê Îî∞Î•∏ body ÌÅ¨Í∏∞ ÎèôÏ†Å Ï°∞Ï†ï
  useEffect(() => {
    if (typeof document === 'undefined') return

    let dynamicBodyStyleElement = document.getElementById('dynamic-body-styles') as HTMLStyleElement
    
    if (!dynamicBodyStyleElement) {
      dynamicBodyStyleElement = document.createElement('style')
      dynamicBodyStyleElement.id = 'dynamic-body-styles'
      document.head.appendChild(dynamicBodyStyleElement)
    }

    const width = centerPosition?.gameAreaBounds.width
    const height = centerPosition?.gameAreaBounds.height
    
    dynamicBodyStyleElement.textContent = createDynamicBodyStyles(width, height)
    
    console.log('üîß [Body ÌÅ¨Í∏∞ Ï°∞Ï†ï]', { width, height })
  }, [centerPosition])


  return (
    <div 
      className="overlay-container"
      style={{
        width: centerPosition ? `${centerPosition.gameAreaBounds.width}px` : '100vw',
        height: centerPosition ? `${centerPosition.gameAreaBounds.height}px` : '100vh'
      }}
    >
      {/* Ìé∏Ïßë Î™®Îìú Î∞∞Í≤Ω Ìö®Í≥º - ÏãúÍ∞ÅÏ†Å ÏßëÏ§ëÏùÑ ÏúÑÌïú Ïò§Î≤ÑÎ†àÏù¥ */}
      {isEditMode && (
        <div 
          className="edit-mode-backdrop"
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            width: '100%',
            height: '100%',
            background: `
              radial-gradient(ellipse at center, 
                rgba(0, 0, 0, 0.2) 0%, 
                rgba(0, 0, 0, 0.6) 70%, 
                rgba(0, 0, 0, 0.8) 100%
              ),
              linear-gradient(
                45deg,
                rgba(0, 153, 255, 0.05) 0%,
                transparent 50%,
                rgba(0, 153, 255, 0.05) 100%
              )
            `,
            pointerEvents: 'none',
            zIndex: 100,
            transition: 'all 0.3s ease-out',
            boxShadow: 'inset 0 0 100px rgba(0, 153, 255, 0.2)',
            filter: 'saturate(1.1)'
          }}
        />
      )}

      {/* Ìé∏Ïßë Î™®Îìú ÏÉÅÌÉú ÌëúÏãú Ìó§Îçî */}
      {isEditMode && (
        <div 
          className="edit-mode-header"
          style={{
            position: 'absolute',
            top: '20px',
            left: '50%',
            transform: 'translateX(-50%)',
            backgroundColor: '#0099ff',
            color: 'white',
            padding: '8px 16px',
            borderRadius: '6px',
            display: 'flex',
            alignItems: 'center',
            gap: '12px',
            boxShadow: '0 4px 20px rgba(0, 153, 255, 0.4)',
            zIndex: 15000,
            fontSize: '14px',
            fontWeight: '600',
            transition: 'all 0.3s ease-out',
            pointerEvents: 'auto'  // Ìó§ÎçîÎäî ÌÅ¥Î¶≠ Í∞ÄÎä•ÌïòÎèÑÎ°ù
          }}
        >
          <span>Ìé∏Ïßë Î™®Îìú ÌôúÏÑ±Ìôî</span>
          <button
            onClick={resetToCenter}
            style={{
              backgroundColor: 'rgba(255, 255, 255, 0.2)',
              color: 'white',
              border: 'none',
              padding: '4px 8px',
              borderRadius: '4px',
              fontSize: '12px',
              cursor: 'pointer',
              transition: 'all 0.2s ease',
              pointerEvents: 'auto'  // Î≤ÑÌäº ÌÅ¥Î¶≠ Í∞ÄÎä•
            }}
            onMouseEnter={(e) => {
              e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.3)'
            }}
            onMouseLeave={(e) => {
              e.currentTarget.style.backgroundColor = 'rgba(255, 255, 255, 0.2)'
            }}
          >
            Î™®Îëê Î¶¨ÏÖã
          </button>
        </div>
      )}

      {/* Ïò§Î≤ÑÎ†àÏù¥ ÏÑ§Ï†ï Î≤ÑÌäº - Ìé∏ÏßëÎ™®ÎìúÏóêÏÑúÎßå ÌëúÏãú */}
      {isEditMode && (
        <button
          onClick={() => setIsSettingsOpen(true)}
          style={{
            position: 'absolute',
            top: '20px',
            right: '20px',
            width: '40px',
            height: '40px',
            borderRadius: '50%',
            border: 'none',
            backgroundColor: 'rgba(0, 0, 0, 0.7)',
            color: 'white',
            cursor: 'pointer',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            fontSize: '18px',
            zIndex: 15000,
            transition: 'all 0.2s ease',
            pointerEvents: 'auto',
            boxShadow: '0 4px 12px rgba(0, 0, 0, 0.3)'
          }}
          onMouseEnter={(e) => {
            e.currentTarget.style.backgroundColor = 'rgba(0, 153, 255, 0.8)'
            e.currentTarget.style.transform = 'scale(1.1)'
          }}
          onMouseLeave={(e) => {
            e.currentTarget.style.backgroundColor = 'rgba(0, 0, 0, 0.7)'
            e.currentTarget.style.transform = 'scale(1)'
          }}
        >
          ‚öôÔ∏è
        </button>
      )}

      {/* ÏùºÍæº ÏÉÅÌÉú Ïò§Î≤ÑÎ†àÏù¥ - InGame ÏÉÅÌÉúÏùº ÎïåÎßå ÌëúÏãú */}
      {(() => {
        const shouldShow = gameStatus === 'playing' && workerStatus && overlaySettings.showWorkerStatus
        return shouldShow ? (
          <WorkerStatus
            ref={workerStatusRef}
            totalWorkers={workerStatus.totalWorkers || 0}
            idleWorkers={workerStatus.idleWorkers || 0}
            productionWorkers={workerStatus.productionWorkers || 0}
            calculatedTotal={workerStatus.calculatedTotal || 0}
            position={workerPosition}
            isEditMode={isEditMode}
            onPositionChange={setWorkerPosition}
          />
        ) : null
      })()}


      {/* ÏúÑÏπò Ï†ïÎ≥¥Í∞Ä ÏóÜÏùÑ Îïå ÏïàÎÇ¥ */}
      {!centerPosition && (
        <div style={{
          position: 'absolute',
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
          color: 'rgba(255,255,255,0.7)',
          fontSize: '16px',
          textAlign: 'center',
          fontFamily: 'Arial, sans-serif'
        }}>
          Ïä§ÌÉÄÌÅ¨ÎûòÌîÑÌä∏ ÏúàÎèÑÏö∞ ÏúÑÏπòÎ•º ÎåÄÍ∏∞ Ï§ë...
        </div>
      )}

      {/* Ïò§Î≤ÑÎ†àÏù¥ ÏÑ§Ï†ï Ìå®ÎÑê */}
      <OverlaySettingsPanel
        isOpen={isSettingsOpen}
        onClose={() => setIsSettingsOpen(false)}
        settings={overlaySettings}
        onSettingsChange={setOverlaySettings}
      />
    </div>
  )
}

// Ï†ÑÏó≠ Ïä§ÌÉÄÏùº
const overlayStyles = `
  .overlay-container {
    position: relative;
    overflow: hidden;
    background: transparent;
    pointer-events: none;
  }

  .edit-mode-backdrop {
    backdrop-filter: blur(8px) saturate(1.2);
    -webkit-backdrop-filter: blur(8px) saturate(1.2);
  }

  /* ÏÉùÏÇ∞ ÏôÑÎ£å Ïù¥ÌéôÌä∏ (ÌååÎûÄÏÉâ) */
  .worker-status.spawn-effect {
    animation: spawnCounterEffect 0.8s ease-out;
    border-color: #2196F3 !important;
    color: #2196F3;
    box-shadow: 
      0 0 30px rgba(33, 150, 243, 0.8),
      inset 0 0 20px rgba(33, 150, 243, 0.2);
  }

  @keyframes spawnCounterEffect {
    0% {
      filter: brightness(1);
    }
    20% {
      filter: brightness(1.5);
      border-color: #64B5F6;
      box-shadow: 
        0 0 40px rgba(33, 150, 243, 1),
        inset 0 0 25px rgba(33, 150, 243, 0.4);
    }
    40% {
      filter: brightness(1.3);
    }
    60% {
      filter: brightness(1.1);
    }
    100% {
      filter: brightness(1);
    }
  }

  /* ÏùºÍæº ÏÇ¨Îßù Ïù¥ÌéôÌä∏ (Îπ®Í∞ÑÏÉâ) */
  .worker-status.death-effect {
    animation: deathCounterEffect 0.6s ease-out;
    border-color: #f44336 !important;
    color: #f44336;
    box-shadow: 
      0 0 25px rgba(244, 67, 54, 0.8),
      inset 0 0 15px rgba(244, 67, 54, 0.3);
  }

  @keyframes deathCounterEffect {
    0% {
      filter: brightness(1);
    }
    10% {
      filter: brightness(1.8) saturate(1.5);
      border-color: #FF5722;
      background: rgba(244, 67, 54, 0.2) !important;
    }
    20% {
      filter: brightness(1.6);
    }
    30% {
      filter: brightness(1.4);
    }
    40% {
      filter: brightness(1.2);
    }
    50% {
      filter: brightness(1.1);
    }
    60% {
      filter: brightness(1.05);
    }
    100% {
      filter: brightness(1);
      background: rgba(0, 0, 0, 0.85) !important;
    }
  }
`

// ÎèôÏ†Å body ÌÅ¨Í∏∞ Ï°∞Ï†ï Ïä§ÌÉÄÏùº
const createDynamicBodyStyles = (width?: number, height?: number) => `
  html, body {
    width: ${width ? `${width}px` : '100vw'} !important;
    height: ${height ? `${height}px` : '100vh'} !important;
    background: transparent;
    overflow: hidden;
    margin: 0;
    padding: 0;
  }

  #root {
    width: ${width ? `${width}px` : '100vw'} !important;
    height: ${height ? `${height}px` : '100vh'} !important;
    background: transparent;
  }
`

// Ïä§ÌÉÄÏùº Ï£ºÏûÖ
if (typeof document !== 'undefined') {
  const styleElement = document.createElement('style')
  styleElement.textContent = overlayStyles
  document.head.appendChild(styleElement)
}